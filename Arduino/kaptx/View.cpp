#include "View.h"

#include <Arduino.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SharpMem.h>

#include "Model.h"

#define REFRESH_INTERVAL 25


#define BLACK 0
#define WHITE 1

// Ids for bitmaps
enum {
    BM_NONE,     // To support nop in showBitmap()
    BM_SHOOT_NO,
    BM_SHOOT_RDY,
    BM_SHOOT_ACT,
    BM_SHOOT_TRIG,
    BM_MODE_SINGLE,
    BM_MODE_CLUSTER,
    BM_MODE_VPAN,
    BM_MODE_HPAN,
    BM_MODE_QUAD,
    BM_MODE_360,
    BM_CIRCLE,
    BM_ARC_0,
    BM_ARC_1,
    BM_ARC_2,
    BM_ARC_15,
    BM_ARC_16,
    BM_ARC_17,
    BM_ARC_18,
    BM_ARC_19,
    BM_ARC_20,
    BM_ARC_21,
    BM_ARC_22,
    BM_ARC_23,
};

// Pins for LCD module.  (Any pins can be used.)
#define LCD_SCK 4
#define LCD_MOSI 5
#define LCD_SS 6

Adafruit_SharpMem display(LCD_SCK, LCD_MOSI, LCD_SS);

// Constructor
View::View(Model *_model) :
  model(_model)
{
    sinceRefresh = 0;
    refreshNeeded = false;
}

// Set up
void View::setup()
{
    // start & clear the display
    display.begin();
    display.setRotation(0);
    
    // set text properties
    display.setTextSize(2);
    display.clearDisplay();

    // Display stuff that is only updated once.
    showBitmap(BM_CIRCLE, BLACK);

    display.refresh();
}

void View::update() 
{
    unsigned char flags = model->getDispFlags();

    sinceRefresh++;
    if (sinceRefresh > REFRESH_INTERVAL) {
	// a refresh should be performed soon
	refreshNeeded = true;
    }

    // The following if..else sequence will draw updates if needed
    // or it will refresh the display if needed but not both.

    if (flags & CHANGE_FLAGS) {
	// draw updates on screen buffer
	drawUpdates(flags);
	
	// A refresh will be needed on the next cycle
	refreshNeeded = true;
    }
    else if (refreshNeeded) {
	// Do a refresh now
	display.refresh();
	sinceRefresh = 0;
	refreshNeeded = false;
    }
}

// ------------------------------------------------------------------------------
// Bitmaps


struct xbm_s {
    uint16_t x;
    uint16_t y;
    uint16_t w;
    uint16_t h;
    const unsigned char *bits;
};

#define PAN_TILT_X_OFFSET 0
#define PAN_TILT_Y_OFFSET 32

#define circ_x (0 + PAN_TILT_X_OFFSET)
#define circ_y (0 + PAN_TILT_Y_OFFSET)
#define circ_width 64
#define circ_height 64
static const unsigned char circ_bits[] PROGMEM = {
    0x00, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x87,
    0xe1, 0x03, 0x00, 0x00, 0x00, 0x00, 0x78, 0x80, 0x01, 0x1e, 0x00, 0x00,
    0x00, 0x00, 0x0e, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x80, 0x03, 0x00,
    0x00, 0xc0, 0x01, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x18, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00,
    0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x0f, 0x00, 0x00,
    0x00, 0x00, 0xf0, 0x00, 0x80, 0x0d, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x01,
    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x02, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
    0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x10, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x08, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0c, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x30, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x06, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x60, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xc0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x40, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x20, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
    0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x0d, 0x00, 0x00,
    0x00, 0x00, 0xb0, 0x01, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00,
    0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x0c, 0x00, 0x00,
    0x00, 0x00, 0x30, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00,
    0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0xc0, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0xc0, 0x01, 0x00,
    0x00, 0x00, 0x0e, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x78, 0x80,
    0x01, 0x1e, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x87, 0xe1, 0x03, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0x00 };

#define arc_0_x (53 + PAN_TILT_X_OFFSET)
#define arc_0_y (21 + PAN_TILT_Y_OFFSET)
#define arc_0_width 8
#define arc_0_height 22
static const unsigned char arc_0_bits[] PROGMEM = {
    0x30, 0x3e, 0x7f, 0x7e, 0x7e, 0x7e, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,
    0xfc, 0xfc, 0xfc, 0xfc, 0x7e, 0x7e, 0x7e, 0x7f, 0x3c, 0x20 };

#define arc_1_x (50 + PAN_TILT_X_OFFSET)
#define arc_1_y (14 + PAN_TILT_Y_OFFSET)
#define arc_1_width 11
#define arc_1_height 21
static const unsigned char arc_1_bits[] PROGMEM = {
    0x10, 0x00, 0x38, 0x00, 0x7c, 0x00, 0x7f, 0x00, 0xfe, 0x00, 0xfe, 0x00,
    0xfc, 0x01, 0xfc, 0x01, 0xf8, 0x01, 0xf8, 0x03, 0xf0, 0x03, 0xf0, 0x03,
    0xf0, 0x03, 0xe0, 0x07, 0xe0, 0x07, 0xe0, 0x07, 0xe0, 0x07, 0xe0, 0x07,
    0xe0, 0x07, 0xe0, 0x07, 0xe0, 0x07 };

#define arc_2_x (46 + PAN_TILT_X_OFFSET)  // x, y in doubt
#define arc_2_y (9 + PAN_TILT_Y_OFFSET)
#define arc_2_width 15
#define arc_2_height 20
static const unsigned char arc_2_bits[] PROGMEM = {
    0x08, 0x00, 0x1c, 0x00, 0x7e, 0x00, 0x7e, 0x00, 0xff, 0x00, 0xfe, 0x01,
    0xfc, 0x03, 0xf8, 0x07, 0xf0, 0x07, 0xe0, 0x0f, 0xe0, 0x0f, 0xc0, 0x1f,
    0xc0, 0x1f, 0x80, 0x1f, 0x80, 0x3f, 0x00, 0x3f, 0x00, 0x3f, 0x00, 0x3f,
    0x00, 0x7e, 0x00, 0x06 };

#define arc_15_x (5 + PAN_TILT_X_OFFSET)
#define arc_15_y (41 + PAN_TILT_Y_OFFSET)
#define arc_15_width 18
#define arc_15_height 18
static const unsigned char arc_15_bits[] PROGMEM = {
    0x30, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x7f, 0x00, 0x00, 0xfe, 0x00, 0x00,
    0xfe, 0x00, 0x00, 0xfc, 0x01, 0x00, 0xfc, 0x03, 0x00, 0xf8, 0x07, 0x00,
    0xf0, 0x0f, 0x00, 0xe0, 0x1f, 0x00, 0xc0, 0x7f, 0x00, 0xc0, 0xff, 0x01,
    0x00, 0xff, 0x03, 0x00, 0xfe, 0x03, 0x00, 0xfc, 0x03, 0x00, 0xf8, 0x01,
    0x00, 0xe0, 0x01, 0x00, 0x80, 0x00 };

#define arc_16_x (10 + PAN_TILT_X_OFFSET)
#define arc_16_y (46 + PAN_TILT_Y_OFFSET)
#define arc_16_width 19
#define arc_16_height 15
static const unsigned char arc_16_bits[] PROGMEM = {
    0x08, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7f, 0x00, 0x00,
    0xff, 0x00, 0x00, 0xfe, 0x03, 0x00, 0xfe, 0x0f, 0x00, 0xf8, 0x3f, 0x00,
    0xf0, 0xff, 0x01, 0xe0, 0xff, 0x07, 0xc0, 0xff, 0x07, 0x00, 0xff, 0x07,
    0x00, 0xfc, 0x07, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x02 };

#define arc_17_x (15 + PAN_TILT_X_OFFSET)
#define arc_17_y (51 + PAN_TILT_Y_OFFSET)
#define arc_17_width 21
#define arc_17_height 10
static const unsigned char arc_17_bits[] PROGMEM = {
    0x1c, 0x00, 0x00, 0x7e, 0x00, 0x00, 0xfe, 0x01, 0x00, 0xff, 0x0f, 0x00,
    0xff, 0xff, 0x0f, 0xfe, 0xff, 0x1f, 0xf8, 0xff, 0x1f, 0xe0, 0xff, 0x1f,
    0x00, 0xff, 0x1f, 0x00, 0xf0, 0x1f };

#define arc_18_x (21 + PAN_TILT_X_OFFSET)
#define arc_18_y (53 + PAN_TILT_Y_OFFSET)
#define arc_18_width 22
#define arc_18_height 8
static const unsigned char arc_18_bits[] PROGMEM = {
    0x04, 0x00, 0x08, 0x3c, 0x00, 0x1f, 0xfe, 0xff, 0x1f, 0xfe, 0xff, 0x1f,
    0xfe, 0xff, 0x3f, 0xff, 0xff, 0x3f, 0xfc, 0xff, 0x0f, 0xc0, 0xff, 0x00 };

#define arc_19_x (29 + PAN_TILT_X_OFFSET)
#define arc_19_y (51 + PAN_TILT_Y_OFFSET)
#define arc_19_width 21
#define arc_19_height 11
static const unsigned char arc_19_bits[] PROGMEM = {
    0x00, 0x00, 0x02, 0x00, 0x80, 0x03, 0x00, 0xe0, 0x07, 0x00, 0xf8, 0x0f,
    0x00, 0xff, 0x1f, 0xff, 0xff, 0x0f, 0xff, 0xff, 0x07, 0xff, 0xff, 0x01,
    0xff, 0x7f, 0x00, 0xff, 0x0f, 0x00, 0xff, 0x00, 0x00 };

#define arc_20_x (35 + PAN_TILT_X_OFFSET)
#define arc_20_y (46 + PAN_TILT_Y_OFFSET)
#define arc_20_width 20
#define arc_20_height 15
static const unsigned char arc_20_bits[] PROGMEM = {
    0x00, 0x80, 0x00, 0x00, 0xc0, 0x03, 0x00, 0xe0, 0x07, 0x00, 0xf0, 0x0f,
    0x00, 0xf8, 0x07, 0x00, 0xfe, 0x03, 0x80, 0xff, 0x03, 0xe0, 0xff, 0x00,
    0xfc, 0x7f, 0x00, 0xff, 0x3f, 0x00, 0xff, 0x1f, 0x00, 0xfe, 0x07, 0x00,
    0xfe, 0x01, 0x00, 0x3e, 0x00, 0x00, 0x02, 0x00, 0x00 };

#define arc_21_x (41 + PAN_TILT_X_OFFSET)
#define arc_21_y (40 + PAN_TILT_Y_OFFSET)
#define arc_21_width 18
#define arc_21_height 18
static const unsigned char arc_21_bits[] PROGMEM = {
    0x00, 0x70, 0x00, 0x00, 0xf8, 0x01, 0x00, 0xf8, 0x03, 0x00, 0xfc, 0x01,
    0x00, 0xfc, 0x01, 0x00, 0xfe, 0x00, 0x00, 0xff, 0x00, 0x80, 0x7f, 0x00,
    0xc0, 0x3f, 0x00, 0xe0, 0x1f, 0x00, 0xf8, 0x0f, 0x00, 0xfe, 0x0f, 0x00,
    0xff, 0x03, 0x00, 0xff, 0x01, 0x00, 0xfe, 0x00, 0x00, 0x7e, 0x00, 0x00,
    0x1c, 0x00, 0x00, 0x04, 0x00, 0x00 };

#define arc_22_x (46 + PAN_TILT_X_OFFSET)
#define arc_22_y (35 + PAN_TILT_Y_OFFSET)
#define arc_22_width 15
#define arc_22_height 19
static const unsigned char arc_22_bits[] PROGMEM = {
    0x00, 0x3e, 0x00, 0x7e, 0x00, 0x3f, 0x00, 0x3f, 0x00, 0x3f, 0x80, 0x3f,
    0x80, 0x1f, 0xc0, 0x1f, 0xc0, 0x1f, 0xe0, 0x0f, 0xe0, 0x0f, 0xf0, 0x07,
    0xf8, 0x07, 0xfc, 0x03, 0xfe, 0x01, 0xff, 0x00, 0x7e, 0x00, 0x7c, 0x00,
    0x18, 0x00 };

#define arc_23_x (51 + PAN_TILT_X_OFFSET)
#define arc_23_y (28 + PAN_TILT_Y_OFFSET)
#define arc_23_width 10
#define arc_23_height 21
static const unsigned char arc_23_bits[] PROGMEM = {
    0xe0, 0x03, 0xf0, 0x03, 0xf0, 0x03, 0xf0, 0x03, 0xf0, 0x03, 0xf0, 0x03,
    0xf0, 0x03, 0xf0, 0x03, 0xf0, 0x03, 0xf8, 0x01, 0xf8, 0x01, 0xf8, 0x01,
    0xfc, 0x01, 0xfc, 0x00, 0xfe, 0x00, 0xfe, 0x00, 0x7f, 0x00, 0x7f, 0x00,
    0x3f, 0x00, 0x3e, 0x00, 0x18, 0x00 };

#define MODE_OFFSET_X 64
#define MODE_OFFSET_Y 0

#define bm_single_x MODE_OFFSET_X
#define bm_single_y MODE_OFFSET_Y
#define bm_single_width 32
#define bm_single_height 32
static const unsigned char bm_single_bits[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0x00, 0xf0, 0x1f, 0x00,
    0x00, 0xf8, 0x3f, 0x00, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0xfc, 0x7f, 0x00,
    0x00, 0xfc, 0x7f, 0x00, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0xfc, 0x7f, 0x00,
    0x00, 0xfc, 0x7f, 0x00, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0xf8, 0x3f, 0x00,
    0x00, 0xf0, 0x1f, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

#define bm_cluster_x MODE_OFFSET_X
#define bm_cluster_y MODE_OFFSET_Y
#define bm_cluster_width 32
#define bm_cluster_height 32
static const unsigned char bm_cluster_bits[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x80, 0x3f, 0xfc, 0x01,
    0xc0, 0x7f, 0xfe, 0x03, 0xc0, 0x7f, 0xfe, 0x03, 0xc0, 0x7f, 0xfe, 0x03,
    0xc0, 0x7f, 0xfe, 0x03, 0xc0, 0x7f, 0xfe, 0x03, 0x80, 0x3f, 0xfc, 0x01,
    0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xf8, 0xc0, 0x07, 0x3e, 0xfc, 0xe1, 0x0f, 0x7f, 0xfe, 0xf3, 0x9f, 0xff,
    0xfe, 0xf3, 0x9f, 0xff, 0xfe, 0xf3, 0x9f, 0xff, 0xfe, 0xf3, 0x9f, 0xff,
    0xfe, 0xf3, 0x9f, 0xff, 0xfc, 0xe1, 0x0f, 0x7f, 0xf8, 0xc0, 0x07, 0x3e,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00,
    0x80, 0x3f, 0xfc, 0x01, 0xc0, 0x7f, 0xfe, 0x03, 0xc0, 0x7f, 0xfe, 0x03,
    0xc0, 0x7f, 0xfe, 0x03, 0xc0, 0x7f, 0xfe, 0x03, 0xc0, 0x7f, 0xfe, 0x03,
    0x80, 0x3f, 0xfc, 0x01, 0x00, 0x1f, 0xf8, 0x00
};

#define bm_vpan_x MODE_OFFSET_X
#define bm_vpan_y MODE_OFFSET_Y
#define bm_vpan_width 32
#define bm_vpan_height 32
static const unsigned char bm_vpan_bits[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0xf0, 0x07, 0x00,
    0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf8, 0x0f, 0x00,
    0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf0, 0x07, 0x00,
    0x00, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xe0, 0x03, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00, 0xf8, 0x0f, 0x00,
    0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf8, 0x0f, 0x00,
    0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00, 0xe0, 0x03, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00,
    0x00, 0xf0, 0x07, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf8, 0x0f, 0x00,
    0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf8, 0x0f, 0x00,
    0x00, 0xf0, 0x07, 0x00, 0x00, 0xe0, 0x03, 0x00
};

#define bm_hpan_x 63
#define bm_hpan_y 1
#define bm_hpan_width 32
#define bm_hpan_height 32
static const unsigned char bm_hpan_bits[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xf8, 0xc0, 0x07, 0x3e, 0xfc, 0xe1, 0x0f, 0x7f, 0xfe, 0xf3, 0x9f, 0xff,
    0xfe, 0xf3, 0x9f, 0xff, 0xfe, 0xf3, 0x9f, 0xff, 0xfe, 0xf3, 0x9f, 0xff,
    0xfe, 0xf3, 0x9f, 0xff, 0xfc, 0xe1, 0x0f, 0x7f, 0xf8, 0xc0, 0x07, 0x3e,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

#define bm_quad_x 63
#define bm_quad_y 1
#define bm_quad_width 32
#define bm_quad_height 32
static const unsigned char bm_quad_bits[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0xf0, 0x01, 0x00, 0x00, 0xf8, 0x03, 0x00, 0x00,
    0xf8, 0x03, 0x00, 0x00, 0xf8, 0x07, 0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00,
    0xf8, 0xe3, 0x00, 0x00, 0xf0, 0x81, 0x03, 0x00, 0x40, 0x00, 0x7e, 0x00,
    0x40, 0x00, 0xfe, 0x00, 0x40, 0x00, 0xfe, 0x00, 0x40, 0x00, 0xfe, 0x00,
    0xf0, 0x01, 0xfe, 0x00, 0xf8, 0x03, 0xfe, 0x00, 0xf8, 0x03, 0xfc, 0x00,
    0xf8, 0x03, 0x80, 0x01, 0xf8, 0x03, 0x00, 0x01, 0xf8, 0x03, 0x00, 0x03,
    0xf0, 0x01, 0x00, 0x02, 0x40, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x06,
    0x40, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x04, 0xf0, 0x81, 0x0f, 0x3e,
    0xf8, 0xc3, 0x1f, 0x7f, 0xf8, 0xc3, 0x1f, 0x7f, 0xf8, 0xff, 0xff, 0x7f,
    0xf8, 0xc3, 0x1f, 0x7f, 0xf8, 0xc3, 0x1f, 0x7f, 0xf0, 0x81, 0x0f, 0x3e,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

#define bm_360_x 63
#define bm_360_y 1
#define bm_360_width 32
#define bm_360_height 32
static const unsigned char bm_360_bits[] PROGMEM = {
    0x00, 0xf0, 0x1f, 0x00, 0x00, 0x1e, 0xf0, 0x00, 0x00, 0x8f, 0xe3, 0x01,
    0xc0, 0x8f, 0xe3, 0x07, 0x60, 0x8e, 0xe3, 0x0c, 0x30, 0x00, 0x00, 0x18,
    0x10, 0x00, 0x00, 0x10, 0x18, 0x00, 0x00, 0x30, 0xcc, 0x71, 0x1c, 0x67,
    0xc4, 0x71, 0x1c, 0x47, 0xc4, 0x71, 0x1c, 0x47, 0x06, 0x00, 0x00, 0xc0,
    0x02, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 0x80, 0x3a, 0x8e, 0xe3, 0xb8,
    0x3a, 0x8e, 0xe3, 0xb8, 0x3a, 0x8e, 0xe3, 0xb8, 0x02, 0x00, 0x00, 0x80,
    0x02, 0x00, 0x00, 0x80, 0x06, 0x00, 0x00, 0xc0, 0xc4, 0x71, 0x1c, 0x47,
    0xc4, 0x71, 0x1c, 0x47, 0xcc, 0x71, 0x1c, 0x67, 0x18, 0x00, 0x00, 0x30,
    0x10, 0x00, 0x00, 0x10, 0x30, 0x00, 0x00, 0x18, 0x60, 0x8e, 0xe3, 0x0c,
    0xc0, 0x8f, 0xe3, 0x07, 0x00, 0x8f, 0xe3, 0x01, 0x00, 0x1e, 0xf0, 0x00,
    0x00, 0xf0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00
};

#define shoot_x 64
#define shoot_y 32
#define shoot_w 32
#define shoot_h 32

#define shutter_no_width 32
#define shutter_no_height 32
static const unsigned char shutter_no_bits[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x0c, 0x00, 0x00, 0x38, 0x0e, 0x00, 0x00, 0x70, 0x07, 0x00,
    0x00, 0xe0, 0x03, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xe0, 0x03, 0x00,
    0x00, 0x70, 0x07, 0x00, 0x00, 0x38, 0x0e, 0x00, 0x00, 0x18, 0x0c, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};

#define shutter_rdy_width 32
#define shutter_rdy_height 32
static const unsigned char shutter_rdy_bits[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x38, 0x0e, 0x00,
    0x00, 0x0c, 0x18, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0x06, 0x30, 0x00,
    0x00, 0x02, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00,
    0x00, 0x06, 0x30, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0x0c, 0x18, 0x00,
    0x00, 0x38, 0x0e, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};

#define shutter_act_width 32
#define shutter_act_height 32
static const unsigned char shutter_act_bits[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0xf8, 0x0f, 0x00,
    0x00, 0xfc, 0x1f, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0xfe, 0x3f, 0x00,
    0x00, 0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00,
    0x00, 0xfe, 0x3f, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0xfc, 0x1f, 0x00,
    0x00, 0xf8, 0x0f, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};

#define shutter_trig_width 32
#define shutter_trig_height 32
static const unsigned char shutter_trig_bits[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00, 0xfc, 0x1f, 0x00,
    0x00, 0xfe, 0x3f, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x80, 0xff, 0xff, 0x00,
    0x80, 0xff, 0xff, 0x00, 0xc0, 0xff, 0xff, 0x01, 0xc0, 0xff, 0xff, 0x01,
    0xc0, 0xff, 0xff, 0x01, 0xc0, 0xff, 0xff, 0x01, 0xc0, 0xff, 0xff, 0x01,
    0xc0, 0xff, 0xff, 0x01, 0xc0, 0xff, 0xff, 0x01, 0x80, 0xff, 0xff, 0x00,
    0x80, 0xff, 0xff, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0xfe, 0x3f, 0x00,
    0x00, 0xfc, 0x1f, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};

// ------------------------------------------------------------------------------
// Utility methods

void View::showBitmap(unsigned char bitmapId, unsigned char color)
{
    switch (bitmapId) {
	case BM_NONE:
	    // No operation
	    break;
	case BM_SHOOT_NO:
	    display.drawXBitmap(shoot_x, shoot_y, shutter_no_bits, shutter_no_width, shutter_no_height, color);
	    break;
	case BM_SHOOT_RDY:
	    display.drawXBitmap(shoot_x, shoot_y, shutter_rdy_bits, shutter_rdy_width, shutter_rdy_height, color);
	    break;
	case BM_SHOOT_ACT:
	    display.drawXBitmap(shoot_x, shoot_y, shutter_act_bits, shutter_act_width, shutter_act_height, color);
	    break;
	case BM_SHOOT_TRIG:
	    display.drawXBitmap(shoot_x, shoot_y, shutter_trig_bits, shutter_trig_width, shutter_trig_height, color);
	    break;
	case BM_MODE_SINGLE:
	    display.drawXBitmap(bm_single_x, bm_single_y, bm_single_bits, bm_single_width, bm_single_height, color);
	    break;
	case BM_MODE_CLUSTER:
	    display.drawXBitmap(bm_cluster_x, bm_cluster_y, bm_cluster_bits, bm_cluster_width, bm_cluster_height, color);
	    break;
	case BM_MODE_VPAN:
	    display.drawXBitmap(bm_vpan_x, bm_vpan_y, bm_vpan_bits, bm_vpan_width, bm_vpan_height, color);
	    break;
	case BM_MODE_HPAN:
	    display.drawXBitmap(bm_hpan_x, bm_hpan_y, bm_hpan_bits, bm_hpan_width, bm_hpan_height, color);
	    break;
	case BM_MODE_QUAD:
	    display.drawXBitmap(bm_quad_x, bm_quad_y, bm_quad_bits, bm_quad_width, bm_quad_height, color);
	    break;
	case BM_MODE_360:
	    display.drawXBitmap(bm_360_x, bm_360_y, bm_360_bits, bm_360_width, bm_360_height, color);
	    break;
	case BM_CIRCLE:
	    display.drawXBitmap(circ_x, circ_y, circ_bits, circ_width, circ_height, color);
	    break;
	case BM_ARC_0:
	    display.drawXBitmap(arc_0_x, arc_0_y, arc_0_bits, arc_0_width, arc_0_height, color);
	    break;
	case BM_ARC_1:
	    display.drawXBitmap(arc_1_x, arc_1_y, arc_1_bits, arc_1_width, arc_1_height, color);
	    break;
	case BM_ARC_2:
	    display.drawXBitmap(arc_2_x, arc_2_y, arc_2_bits, arc_2_width, arc_2_height, color);
	    break;
	case BM_ARC_15:
	    display.drawXBitmap(arc_15_x, arc_15_y, arc_15_bits, arc_15_width, arc_15_height, color);
	    break;
	case BM_ARC_16:
	    display.drawXBitmap(arc_16_x, arc_16_y, arc_16_bits, arc_16_width, arc_16_height, color);
	    break;
	case BM_ARC_17:
	    display.drawXBitmap(arc_17_x, arc_17_y, arc_17_bits, arc_17_width, arc_17_height, color);
	    break;
	case BM_ARC_18:
	    display.drawXBitmap(arc_18_x, arc_18_y, arc_18_bits, arc_18_width, arc_18_height, color);
	    break;
	case BM_ARC_19:
	    display.drawXBitmap(arc_19_x, arc_19_y, arc_19_bits, arc_19_width, arc_19_height, color);
	    break;
	case BM_ARC_20:
	    display.drawXBitmap(arc_20_x, arc_20_y, arc_20_bits, arc_20_width, arc_20_height, color);
	    break;
	case BM_ARC_21:
	    display.drawXBitmap(arc_21_x, arc_21_y, arc_21_bits, arc_21_width, arc_21_height, color);
	    break;
	case BM_ARC_22:
	    display.drawXBitmap(arc_22_x, arc_22_y, arc_22_bits, arc_22_width, arc_22_height, color);
	    break;
	case BM_ARC_23:
	    display.drawXBitmap(arc_23_x, arc_23_y, arc_23_bits, arc_23_width, arc_23_height, color);
	    break;
    }
}

void View::showShutter(unsigned char state)
{
    unsigned char bitmapId;

    // Serial.println(m);
    switch (state) {
	case SHUTTER_STATE_NO:
	    bitmapId = BM_SHOOT_NO;
	    break;
	case SHUTTER_STATE_RDY:
	    bitmapId = BM_SHOOT_RDY;
	    break;
	case SHUTTER_STATE_ACT:
	    bitmapId = BM_SHOOT_ACT;
	    break;
	case SHUTTER_STATE_TRIG:
	    bitmapId = BM_SHOOT_TRIG;
	    break;
	default:
	    bitmapId = BM_NONE;
	    break;
    }

    // erase old bitmap
    display.fillRect(shoot_x, shoot_y, 32, 32, WHITE);

    // show new bitmap
    showBitmap(bitmapId, BLACK);
}

void View::showShootMode(unsigned char mode, bool invMode)
{
    unsigned char bitmapId;

    // Serial.println(m);
    switch (mode) {
	case MODE_SINGLE:
	    bitmapId = BM_MODE_SINGLE;
	    break;
	case MODE_CLUSTER:
	    bitmapId = BM_MODE_CLUSTER;
	    break;
	case MODE_VPAN:
	    bitmapId = BM_MODE_VPAN;
	    break;
	case MODE_HPAN:
	    bitmapId = BM_MODE_HPAN;
	    break;
	case MODE_QUAD:
	    bitmapId = BM_MODE_QUAD;
	    break;
	case MODE_360:
	    bitmapId = BM_MODE_360;
	    break;
	default:
	    bitmapId = BM_NONE;
	    break;
    }

    int color = WHITE;  // normal background color
    if (invMode) {
	color = !color;  // invert color scheme
    }

    // erase old bitmap
    display.fillRect(MODE_OFFSET_X, MODE_OFFSET_Y, 32, 32, color);

    // show new bitmap
    color = !color;
    showBitmap(bitmapId, color);
}

#define SHOTS_ORIGIN_X 0
#define SHOTS_ORIGIN_Y 0
#define SHOTS_WIDTH 64
#define SHOTS_HEIGHT 32
#define SHOTS_CURSOR_X 8
#define SHOTS_CURSOR_Y 8

void View::showShots(bool autokap, int shots, bool inv)
{
    char buf[6];

    // create text in buffer
    if (autokap) {
	strcpy_P(buf, (const char *)F("AUTO"));
    }
    else if (inv) {
	// This control is highlighted, so show "MAN" instead of count
	strcpy_P(buf, (const char *)F(" MAN"));
    }
    else {
	sprintf_P(buf, (const char *)F("%4d"), shots);
    }

    // erase earlier content, set text color based on inverse state
    if (inv) {
	display.fillRect(SHOTS_ORIGIN_X, SHOTS_ORIGIN_Y, SHOTS_WIDTH-1, SHOTS_HEIGHT-1, BLACK);
	display.setTextColor(WHITE, BLACK);
    }
    else {
	display.fillRect(SHOTS_ORIGIN_X, SHOTS_ORIGIN_Y, SHOTS_WIDTH-1, SHOTS_HEIGHT-1, WHITE);
	display.setTextColor(BLACK, WHITE);
    }

    // position cursor
    display.setCursor(SHOTS_CURSOR_X+SHOTS_ORIGIN_X, SHOTS_CURSOR_Y+SHOTS_ORIGIN_Y);

    // display it!
    display.print(buf); 
}

#define HOVER_ORIGIN_X 64
#define HOVER_ORIGIN_Y 64
#define HOVER_HOR_X 5
#define HOVER_HOR_Y 8
#define HOVER_HOR_W 22
#define HOVER_HOR_H 14
#define HOVER_VER_X (HOVER_HOR_Y)
#define HOVER_VER_Y (HOVER_HOR_X)
#define HOVER_VER_W (HOVER_HOR_H)
#define HOVER_VER_H (HOVER_HOR_W)

void View::showHoVer(bool vertical, bool inv)
{
    unsigned char color;

    // clear the Ho/Ver area
    color = WHITE;  // assume we erase with white
    if (inv) {
	color = !color;  // erase with black
    }
    display.fillRect(HOVER_ORIGIN_X, HOVER_ORIGIN_Y, 31, 31, color);

    color = !color;  // draw with opposite as background
    if (vertical) {
	// vertical
	display.drawRect(HOVER_VER_X+HOVER_ORIGIN_X, HOVER_VER_Y + HOVER_ORIGIN_Y, HOVER_VER_W, HOVER_VER_H, color);
	display.drawRect(HOVER_VER_X+HOVER_ORIGIN_X+1, HOVER_VER_Y+HOVER_ORIGIN_Y+1, HOVER_VER_W-2, HOVER_VER_H-2, color);
    }
    else {
	// horizontal
	display.drawRect(HOVER_HOR_X+HOVER_ORIGIN_X, HOVER_HOR_Y + HOVER_ORIGIN_Y, HOVER_HOR_W, HOVER_HOR_H, color);
	display.drawRect(HOVER_HOR_X+HOVER_ORIGIN_X+1, HOVER_HOR_Y+HOVER_ORIGIN_Y+1, HOVER_HOR_W-2, HOVER_HOR_H-2, color);
    }
}

// Triangle vertices for each view of the pan indicator.
struct PanInd_s {
    uint8_t x0;
    uint8_t y0;
    uint8_t x1;
    uint8_t y1;
    uint8_t x2;
    uint8_t y2;
};

const struct PanInd_s panIndicator[24] PROGMEM =
{
    {56,64,16,72,16,57}, // 0
    {55,58,19,75,15,61},
    {52,53,23,78,15,65},
    {48,48,27,80,16,69},
    {43,44,31,81,18,73},
    {38,41,35,81,21,77},
    {32,40,40,80,24,80}, // 6
    {26,41,43,77,29,81},
    {20,44,46,73,33,81},
    {16,48,48,69,37,80},
    {12,52,49,65,41,78},
    {9,58,49,61,45,75},
    {8,64,48,56,48,72}, // 12
    {9,70,45,53,49,67},
    {12,76,41,50,49,63},
    {16,80,37,48,48,59},
    {20,84,33,47,46,55},
    {26,87,29,47,43,51},
    {32,88,24,49,39,48}, // 18
    {38,87,21,51,35,47},
    {43,84,18,55,31,47},
    {48,80,16,59,27,48},
    {52,76,15,63,23,50},
    {55,70,15,67,19,53},
};

void View::showPan(int pan)
{
    static uint16_t x0 = 0;
    static uint16_t y0 = 0;
    static uint16_t x1 = 0;
    static uint16_t y1 = 0;
    static uint16_t x2 = 0;
    static uint16_t y2 = 0;

    // erase old triangle
    display.fillTriangle(x0, y0, x1, y1, x2, y2, WHITE);

    // clear pan area
    // Serial.println(pan);
    x0 = pgm_read_byte(&panIndicator[pan].x0);
    y0 = pgm_read_byte(&panIndicator[pan].y0);
    x1 = pgm_read_byte(&panIndicator[pan].x1);
    y1 = pgm_read_byte(&panIndicator[pan].y1);
    x2 = pgm_read_byte(&panIndicator[pan].x2);
    y2 = pgm_read_byte(&panIndicator[pan].y2);

    // draw new triangle
    display.fillTriangle(x0, y0, x1, y1, x2, y2, BLACK);
}

void View::showTilt(int tilt)
{
    static unsigned char old_bitmapId = BM_NONE;
    unsigned char bitmapId;

    switch (tilt) {
	case 0:
	    bitmapId = BM_ARC_0;
	    break;
	case 1:
	    bitmapId = BM_ARC_1;
	    break;
	case 2:
	    bitmapId = BM_ARC_2;
	    break;
	case 15:
	    bitmapId = BM_ARC_15;
	    break;
	case 16:
	    bitmapId = BM_ARC_16;
	    break;
	case 17:
	    bitmapId = BM_ARC_17;
	    break;
	case 18:
	    bitmapId = BM_ARC_18;
	    break;
	case 19:
	    bitmapId = BM_ARC_19;
	    break;
	case 20:
	    bitmapId = BM_ARC_20;
	    break;
	case 21:
	    bitmapId = BM_ARC_21;
	    break;
	case 22:
	    bitmapId = BM_ARC_22;
	    break;
	case 23:
	    bitmapId = BM_ARC_23;
	    break;
	default:
	    bitmapId = BM_NONE;
    }

    // erase old bitmap
    showBitmap(old_bitmapId, WHITE);

    // show new bitmap
    showBitmap(bitmapId, BLACK);

    // remember old for next time
    old_bitmapId = bitmapId;
}

void View::drawUpdates(unsigned char flags)
{
    PanTilt_t aimPoint;

    // Serial.println("Update.");
    if (flags & REFRESH_PAN_TILT) {
	model->getUserPos(&aimPoint);
	showPan(aimPoint.pan);
	showTilt(aimPoint.tilt);
    }
    if (flags & REFRESH_HOVER) {
	showHoVer(model->getHoVer(), !!(flags & INV_HOVER));
    }
    if (flags & REFRESH_SHUTTER) {
	showShutter(model->getLcdShutterState());
    }
    if (flags & REFRESH_SHOOT_MODE) {
	showShootMode(model->getShootModeDisp(), !!(flags & INV_SHOOT_MODE));
    }
    if (flags & REFRESH_AUTO_COUNT) {
	showShots(model->getAuto(), model->getShotsQueued(), !!(flags & INV_AUTO_COUNT));
    }
}


